# 订阅检查逻辑修正：避免重复订阅

## 问题分析

### 用户的正确质疑

如果订阅检查使用 `oracle_id`：
- 第一次订阅 `PUMP-PERP` (oracle_id="pubkey-1")，检查 `oracle_id in data_map`，不存在，所以订阅
- 第二次订阅 `1KPUMP-PERP` (oracle_id="pubkey-2")，检查 `oracle_id in data_map`，不存在，所以也订阅
- **但是这两个 `oracle_id` 对应的是同一个 `pubkey`！**
- **结果：同一个 `pubkey` 被订阅了两次！** ❌

---

## Rust SDK 的正确做法

### Rust SDK 的订阅检查逻辑

**Rust SDK** (`oraclemap.rs` L161-172):
```rust
// markets can share oracle pubkeys, only want one sub per oracle pubkey
if self.subscriptions.contains_key(oracle_pubkey)  // ⭐ 检查 pubkey
    || pending_subscriptions
        .iter()
        .any(|sub| &sub.pubkey == oracle_pubkey)  // ⭐ 检查 pubkey
{
    log::debug!(
        target: LOG_TARGET,
        "subscription exists: {market:?}/{oracle_pubkey:?}"
    );
    continue;  // ⭐ 跳过，不重复订阅
}
```

**关键点**：
1. ✅ **订阅检查使用 `pubkey`**（不是 `oracle_id` 或 `MarketId`）
2. ✅ **如果 `pubkey` 已经订阅，跳过**（`continue`），不重复订阅
3. ✅ **但是，会记录多个 `OracleSource` 到同一个订阅**（通过 `OracleShareMode::Mixed`）

### Rust SDK 的数据更新逻辑

**Rust SDK** (`oraclemap.rs` L195-204):
```rust
match &oracle_shared_mode_ref {
    OracleShareMode::Normal { source } => {
        update_handler(update, *source, &oraclemap)  // 单个 source
    }
    OracleShareMode::Mixed { sources } => {
        for source in sources {  // ⭐ 遍历所有 sources
            update_handler(update, *source, &oraclemap);
        }
    }
}
```

**关键点**：
- ✅ **一个订阅（一个 `pubkey`）可以对应多个 `OracleSource`**
- ✅ **数据更新时，遍历所有 `sources`，分别解码和存储**

---

## 修正后的方案

### 关键原则

1. **订阅检查**：使用 `pubkey`（避免重复订阅）
2. **数据存储**：使用 `oracle_id` 作为 key（支持同一 pubkey 多个 source）
3. **数据获取**：使用 `oracle_id` 获取（类似 Rust SDK 的 `MarketId`）

### 修正后的订阅检查逻辑

#### 1. `subscribe_to_oracle` 和 `subscribe_to_oracle_info`

**原有代码** (`drift_client.py` L184, L207):
```python
if full_oracle_wrapper.pubkey in self.oracle_subscriber.data_map:  # ⚠️ 错误
    return
```

**修正后**：
```python
async def subscribe_to_oracle(self, full_oracle_wrapper: FullOracleWrapper):
    if full_oracle_wrapper.pubkey == Pubkey.default():
        return

    oracle_id = get_oracle_id(
        full_oracle_wrapper.pubkey,
        full_oracle_wrapper.oracle_source,
    )
    
    # ✅ 订阅检查：使用 pubkey（避免重复订阅）
    if full_oracle_wrapper.pubkey in self.oracle_subscriber.pubkey_to_subscription:
        # pubkey 已经订阅，只需要添加 oracle_id 映射
        self.oracle_id_to_pubkey[oracle_id] = full_oracle_wrapper.pubkey
        # 添加到 pubkey_to_oracle_ids 映射
        if full_oracle_wrapper.pubkey not in self.oracle_subscriber.pubkey_to_oracle_ids:
            self.oracle_subscriber.pubkey_to_oracle_ids[full_oracle_wrapper.pubkey] = set()
        self.oracle_subscriber.pubkey_to_oracle_ids[full_oracle_wrapper.pubkey].add(oracle_id)
        return

    # pubkey 未订阅，需要订阅
    await self.oracle_subscriber.add_account(
        full_oracle_wrapper.pubkey,
        get_oracle_decode_fn(full_oracle_wrapper.oracle_source),
        initial_data=full_oracle_wrapper.oracle_price_data_and_slot,
        oracle_id=oracle_id,  # ⭐ 传递 oracle_id
    )
    self.oracle_id_to_pubkey[oracle_id] = full_oracle_wrapper.pubkey
```

**关键点**：
- ✅ **订阅检查使用 `pubkey`**（`pubkey in pubkey_to_subscription`）
- ✅ **如果 `pubkey` 已订阅，只添加 `oracle_id` 映射**（不重复订阅）
- ✅ **如果 `pubkey` 未订阅，才调用 `add_account`**（传递 `oracle_id`）

#### 2. `add_account` 方法

**修正后的逻辑**：
```python
async def add_account(
    self,
    pubkey: Pubkey,
    decode: Optional[Callable[[bytes], Any]] = None,
    initial_data: Optional[DataAndSlot] = None,
    oracle_id: Optional[str] = None,  # ⭐ 新增可选参数
):
    # 确定内部 key
    if oracle_id is not None:
        key = oracle_id
    else:
        key = str(pubkey)
    
    # 存储解码器
    if decode is not None:
        self.decode_map[key] = decode
    
    # 存储初始数据
    if initial_data is not None:
        self.data_map[key] = initial_data
    
    # ⭐ 关键：维护 pubkey_to_oracle_ids 映射
    if oracle_id is not None:
        if pubkey not in self.pubkey_to_oracle_ids:
            self.pubkey_to_oracle_ids[pubkey] = set()
        self.pubkey_to_oracle_ids[pubkey].add(oracle_id)
    
    # ⭐ 关键：检查 pubkey 是否已经订阅（避免重复订阅）
    if pubkey in self.pubkey_to_subscription:
        # pubkey 已经订阅，不需要再次订阅
        # 只需要确保 oracle_id 映射正确
        subscription_id = self.pubkey_to_subscription[pubkey]
        if oracle_id is not None:
            self.oracle_id_to_subscription[oracle_id] = subscription_id
        return
    
    # pubkey 未订阅，需要订阅
    # ... 订阅逻辑（使用 request_id 匹配）...
```

**关键点**：
- ✅ **检查 `pubkey` 是否已经订阅**（`pubkey in pubkey_to_subscription`）
- ✅ **如果已订阅，只添加 `oracle_id` 映射**（不重复订阅）
- ✅ **如果未订阅，才发送订阅请求**

---

## 完整的修正方案

### 1. 订阅检查：使用 `pubkey`

**目的**：避免重复订阅同一个 `pubkey`

**实现**：
```python
# 在 subscribe_to_oracle 和 subscribe_to_oracle_info 中
if pubkey in self.oracle_subscriber.pubkey_to_subscription:
    # 已订阅，只添加 oracle_id 映射
    return
```

### 2. 数据存储：使用 `oracle_id` 作为 key

**目的**：支持同一 `pubkey` 多个 `oracle_id`

**实现**：
```python
# 在 add_account 中
if oracle_id is not None:
    key = oracle_id
else:
    key = str(pubkey)

self.decode_map[key] = decode
self.data_map[key] = initial_data
```

### 3. 数据更新：遍历所有 `oracle_id`

**目的**：一个订阅更新多个 `oracle_id` 的数据

**实现**：
```python
# 在 _subscribe_ws 的数据更新处理中
pubkey = self.subscription_map.get(subscription_id)
if pubkey is not None:
    oracle_ids = self.pubkey_to_oracle_ids.get(pubkey, set())
    for oracle_id in oracle_ids:
        decode_fn = self.decode_map.get(oracle_id)
        if decode_fn is not None:
            decoded_data = decode_fn(account_bytes)
            self.data_map[oracle_id] = DataAndSlot(decoded_data, slot)
```

### 4. 数据获取：使用 `oracle_id`

**目的**：类似 Rust SDK 的 `get_by_market(market)`

**实现**：
```python
# 在 get_oracle_price_data_and_slot 中
def get_oracle_price_data_and_slot(
    self, oracle_id: str
) -> Optional[DataAndSlot[OraclePriceData]]:
    # ✅ 直接使用 oracle_id（类似 Rust SDK 使用 MarketId）
    return self.oracle_subscriber.get_data(oracle_id)
```

---

## 总结

### 关键修正

1. ✅ **订阅检查使用 `pubkey`**：避免重复订阅
2. ✅ **数据存储使用 `oracle_id`**：支持同一 `pubkey` 多个 `oracle_id`
3. ✅ **数据更新遍历所有 `oracle_id`**：一个订阅更新多个数据
4. ✅ **数据获取使用 `oracle_id`**：类似 Rust SDK 的 `get_by_market(market)`

### 与 Rust SDK 的一致性

| 方面 | Rust SDK | Python SDK（修正后） |
|------|----------|---------------------|
| **订阅检查** | `subscriptions.contains_key(pubkey)` | `pubkey in pubkey_to_subscription` |
| **数据存储** | `(Pubkey, u8) -> Oracle` | `oracle_id -> DataAndSlot` |
| **数据更新** | 遍历 `OracleShareMode::Mixed.sources` | 遍历 `pubkey_to_oracle_ids[pubkey]` |
| **数据获取** | `get_by_market(market: MarketId)` | `get_data(oracle_id: str)` |
