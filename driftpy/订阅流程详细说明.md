# WebSocket订阅流程详细说明

## 场景：并行订阅3个预言机账户

假设我们要订阅3个预言机：
- **Oracle A**: `Pubkey_A`，使用 `PythLazer` 解码器
- **Oracle B**: `Pubkey_B`，使用 `PythLazer1K` 解码器  
- **Oracle C**: `Pubkey_C`，使用 `PythPull` 解码器

## 第一步：发送订阅请求

```python
# 代码位置：multi_account_subscriber.py L130-136
for pubkey in initial_accounts:  # [Pubkey_A, Pubkey_B, Pubkey_C]
    await ws.account_subscribe(pubkey, ...)
```

**实际发送的WebSocket消息**（简化）：
```
请求1: {"id": 1, "method": "accountSubscribe", "params": [Pubkey_A, ...]}
请求2: {"id": 2, "method": "accountSubscribe", "params": [Pubkey_B, ...]}
请求3: {"id": 3, "method": "accountSubscribe", "params": [Pubkey_C, ...]}
```

**关键点**：
- 每个请求都有唯一的 `id`（1, 2, 3）
- 请求是**并行发送**的（在同一个循环中快速发送）
- `pending_subscriptions = [Pubkey_A, Pubkey_B, Pubkey_C]`（按发送顺序）

## 第二步：接收订阅确认消息

**RPC服务器返回的确认消息**（可能乱序）：

```
确认消息1: {"id": 2, "result": 1001}  ← 这是请求2的确认，subscription_id=1001
确认消息2: {"id": 3, "result": 1002}  ← 这是请求3的确认，subscription_id=1002
确认消息3: {"id": 1, "result": 1000}  ← 这是请求1的确认，subscription_id=1000
```

**注意**：确认消息是**乱序返回**的！请求1最后返回。

## 第三步：当前代码的处理（有BUG）

```python
# 代码位置：multi_account_subscriber.py L151-159
if isinstance(result, int):  # 收到确认消息
    if self.pending_subscriptions:
        pubkey = self.pending_subscriptions.pop(0)  # ⚠️ 总是取第一个！
        subscription_id = result
        self.subscription_map[subscription_id] = pubkey
```

**错误的匹配过程**：

1. **收到确认消息1** (`id=2, result=1001`)：
   - `pending_subscriptions = [Pubkey_A, Pubkey_B, Pubkey_C]`
   - `pop(0)` → 取出 `Pubkey_A`（第一个）
   - **错误匹配**：`subscription_map[1001] = Pubkey_A` ❌
   - 应该是：`subscription_map[1001] = Pubkey_B` ✅

2. **收到确认消息2** (`id=3, result=1002`)：
   - `pending_subscriptions = [Pubkey_B, Pubkey_C]`
   - `pop(0)` → 取出 `Pubkey_B`
   - **错误匹配**：`subscription_map[1002] = Pubkey_B` ❌
   - 应该是：`subscription_map[1002] = Pubkey_C` ✅

3. **收到确认消息3** (`id=1, result=1000`)：
   - `pending_subscriptions = [Pubkey_C]`
   - `pop(0)` → 取出 `Pubkey_C`
   - **错误匹配**：`subscription_map[1000] = Pubkey_C` ❌
   - 应该是：`subscription_map[1000] = Pubkey_A` ✅

**最终错误的映射**：
```
subscription_map = {
    1000: Pubkey_C,  ❌ 应该是 Pubkey_A
    1001: Pubkey_A,  ❌ 应该是 Pubkey_B
    1002: Pubkey_B   ❌ 应该是 Pubkey_C
}
```

## 第四步：接收数据更新消息（后续问题）

当账户数据更新时，RPC发送通知：

```
数据更新1: {"subscription": 1001, "result": {...账户数据...}}
```

**代码处理**（L167-193）：
```python
subscription_id = msg[0].subscription  # 1001
pubkey = self.subscription_map[subscription_id]  # 错误地得到 Pubkey_A
decode_fn = self.decode_map.get(pubkey)  # 使用 Pubkey_A 的解码器
decoded_data = decode_fn(account_bytes)  # ❌ 用错误的解码器解码！
```

**问题**：
- `subscription_id=1001` 实际对应 `Pubkey_B` 的数据
- 但代码用 `Pubkey_A` 的解码器（`PythLazer`）去解码
- 应该用 `Pubkey_B` 的解码器（`PythLazer1K`）
- **结果**：解码失败或得到错误的价格数据！

## 问题的根源

### BUG2的核心问题：

1. **订阅确认消息不包含pubkey信息**
   - 确认消息只有：`{"id": 2, "result": 1001}`
   - 没有告诉我们这个 `subscription_id=1001` 对应哪个 `pubkey`

2. **代码假设确认消息按顺序返回**
   - 使用 `pending_subscriptions.pop(0)` 假设第一个确认对应第一个请求
   - 但RPC可能乱序返回，导致错配

3. **错配的后果**
   - `subscription_id` 和 `pubkey` 的映射错误
   - 后续数据更新用错误的解码器解码
   - 导致价格数据错误

## 解决方案

### 方案：使用响应消息的 `id` 字段

**关键发现**：确认消息包含 `id` 字段，对应请求的 `id`！

**正确的处理方式**：

```python
# 发送请求时，记录 id -> pubkey 映射
pending_requests = {
    1: Pubkey_A,
    2: Pubkey_B,
    3: Pubkey_C
}

# 收到确认时
if isinstance(result, int):
    request_id = msg[0].id  # 从响应中获取 id
    pubkey = pending_requests[request_id]  # 准确匹配！
    subscription_id = result
    self.subscription_map[subscription_id] = pubkey
    del pending_requests[request_id]
```

**但问题**：`solana-py` 的 `account_subscribe` 方法内部生成 `id`，我们无法直接获取。

**需要确认**：
1. 响应消息对象 `msg[0]` 是否包含 `id` 属性？
2. 如何获取请求的 `id`？

## 总结

**你的理解是正确的**：
- ✅ 并行订阅多个账户
- ✅ 确认消息乱序返回
- ✅ 无法确定哪个 `subscription_id` 对应哪个 `pubkey`
- ✅ 导致后续数据更新用错误的解码器

**但有一个关键点**：
- 确认消息**包含 `id` 字段**，理论上可以匹配
- 需要检查代码是否能访问这个 `id` 字段
