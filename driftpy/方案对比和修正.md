# 方案对比和修正：与Rust SDK的关键差异

## 关键发现：我的方案与Rust SDK的重要差异

### Rust SDK的BUG1解决方案

#### 1. 订阅逻辑（关键！）

**Rust SDK** (`oraclemap.rs` L157-181):
```rust
for market in markets {
    let (oracle_pubkey, _oracle_source) = ...;
    
    // ⭐ 关键：markets can share oracle pubkeys, only want one sub per oracle pubkey
    // 同一pubkey只订阅一次（即使有多个source）
    if self.subscriptions.contains_key(oracle_pubkey)
        || pending_subscriptions.iter().any(|sub| &sub.pubkey == oracle_pubkey)
    {
        continue;  // 已订阅，跳过
    }
    
    // 创建订阅器（只按pubkey）
    let oracle_subscriber = WebsocketAccountSubscriber::new(
        Arc::clone(&self.pubsub),
        *oracle_pubkey,  // ⭐ 只按pubkey订阅
        self.commitment,
    );
    
    pending_subscriptions.push(oracle_subscriber);
}
```

**关键点**：
- ✅ **同一pubkey只订阅一次**（即使有多个source）
- ✅ **共享WS订阅**：所有使用同一pubkey的markets共享同一个WS订阅

#### 2. 更新处理逻辑

**Rust SDK** (`oraclemap.rs` L194-206):
```rust
let unsub = sub_fut.subscribe(..., move |update| {
    match &oracle_shared_mode_ref {
        OracleShareMode::Normal { source } => {
            // 只有一个source，直接处理
            update_handler(update, *source, &oraclemap)
        }
        OracleShareMode::Mixed { sources } => {
            // ⭐ 关键：多个sources，遍历所有sources处理
            for source in sources {
                update_handler(update, *source, &oraclemap);
            }
        }
    }
    on_account(update);
})
```

**关键点**：
- ✅ **收到更新时，如果是Mixed，遍历所有sources解码**
- ✅ **每个source都调用`update_handler`，存储到对应的`(pubkey, source_u8)` key**

#### 3. 存储key

**Rust SDK** (`oraclemap.rs` L55):
```rust
pub oraclemap: Arc<DashMap<(Pubkey, u8), Oracle>>
// ⭐ 使用 (Pubkey, u8) 作为key，其中u8是OracleSource的枚举值
```

**关键点**：
- ✅ **使用`(Pubkey, u8)`作为key**：每个source对应一个独立的存储位置

---

## 我的方案的问题

### 问题1：订阅逻辑不一致

**我的方案**：
```python
# 每个oracle_id都会订阅
for pubkey, oracle_id in initial_subscriptions:
    await ws.send(json.dumps({
        "method": "accountSubscribe",
        "params": [str(pubkey), ...]
    }))
```

**问题**：
- ❌ **同一pubkey会订阅多次**（每个oracle_id一次）
- ❌ **浪费WS连接资源**
- ❌ **与Rust SDK的逻辑不一致**

**Rust SDK的逻辑**：
- ✅ **同一pubkey只订阅一次**
- ✅ **收到更新时，用所有sources解码**

### 问题2：缺少共享oracle检测

**Rust SDK** (`oraclemap.rs` L90-111):
```rust
// ⭐ 初始化时检测共享oracle
let shared_oracles = DashMap::<Pubkey, OracleShareMode>::default();
for (_market, (pubkey, source)) in oracle_by_market.iter() {
    shared_oracles.entry(*pubkey).and_modify(|m| match m {
        OracleShareMode::Normal { source: existing_source } => {
            if existing_source != source {
                *m = OracleShareMode::Mixed {
                    sources: vec![*existing_source, *source],
                }
            }
        }
        OracleShareMode::Mixed { sources } => {
            if !sources.contains(source) {
                sources.push(*source);
            }
        }
    }).or_insert(OracleShareMode::Normal { source: *source });
}
```

**我的方案**：
- ❌ **没有检测共享oracle的逻辑**
- ❌ **没有`OracleShareMode`的概念**

---

## 修正后的方案

### 修正1：订阅逻辑 - 按pubkey去重

**修正后的`add_account`方法**：
```python
async def add_account(
    self,
    pubkey: Pubkey,
    decode: Optional[Callable[[bytes], Any]] = None,
    initial_data: Optional[DataAndSlot] = None,
    oracle_id: Optional[str] = None,
):
    decode_fn = decode if decode is not None else self.program.coder.accounts.decode
    key = oracle_id if oracle_id is not None else str(pubkey)
    
    async with self._lock:
        # ⭐ 检查oracle_id是否已存在
        if oracle_id and oracle_id in self.data_map:
            return
        if not oracle_id and pubkey in self.pubkey_to_subscription:
            return
        
        # ⭐ 存储解码器和数据（使用oracle_id作为key）
        self.decode_map[key] = decode_fn
        self.initial_data_map[key] = initial_data
        self.data_map[key] = initial_data
        
        # ⭐ 维护pubkey到oracle_id的映射
        if oracle_id:
            if pubkey not in self.pubkey_to_oracle_ids:
                self.pubkey_to_oracle_ids[pubkey] = set()
            self.pubkey_to_oracle_ids[pubkey].add(oracle_id)
    
    # ⭐ 关键：检查pubkey是否已订阅（按pubkey去重）
    async with self._lock:
        pubkey_already_subscribed = pubkey in self.pubkey_to_subscription
    
    if not pubkey_already_subscribed:
        # ⭐ 只有pubkey未订阅时才发送订阅请求
        if self.ws is not None:
            try:
                request_id = next(self.request_id_counter)
                async with self._lock:
                    self.inflight_subscribes[request_id] = (pubkey, None)  # oracle_id设为None，因为可能多个
                    self.pending_subscriptions.append((pubkey, None))
                
                # 发送订阅请求
                commitment_str = str(self.commitment) if self.commitment else "confirmed"
                message = {
                    "jsonrpc": "2.0",
                    "id": request_id,
                    "method": "accountSubscribe",
                    "params": [str(pubkey), {"encoding": "base64", "commitment": commitment_str}]
                }
                await self.ws.send(json.dumps(message))
            except Exception as e:
                print(f"Error subscribing to account {pubkey}: {e}")
```

**关键修正**：
- ✅ **按pubkey去重**：同一pubkey只订阅一次
- ✅ **存储所有oracle_id**：即使只订阅一次，也存储所有oracle_id的解码器

### 修正2：更新处理逻辑 - 遍历所有sources

**修正后的数据更新处理**：
```python
if hasattr(result, "value") and result.value is not None:
    subscription_id = msg[0].subscription
    
    if subscription_id not in self.subscription_map:
        continue
    
    pubkey = self.subscription_map[subscription_id]
    
    # ⭐ 关键：获取该pubkey对应的所有oracle_id
    oracle_ids = self.pubkey_to_oracle_ids.get(pubkey, set())
    
    if len(oracle_ids) == 0:
        # 向后兼容：没有oracle_id，使用pubkey
        key = str(pubkey)
        decode_fn = self.decode_map.get(key)
        if decode_fn:
            try:
                slot = int(result.context.slot)
                account_bytes = cast(bytes, result.value.data)
                decoded_data = decode_fn(account_bytes)
                new_data = DataAndSlot(slot, decoded_data)
                self._update_data(key, new_data)
            except Exception:
                pass
    else:
        # ⭐ 关键：遍历所有oracle_id，每个都解码并存储（类似Rust SDK的Mixed模式）
        account_bytes = cast(bytes, result.value.data)
        slot = int(result.context.slot)
        
        for oracle_id in oracle_ids:
            decode_fn = self.decode_map.get(oracle_id)
            if decode_fn:
                try:
                    decoded_data = decode_fn(account_bytes)
                    new_data = DataAndSlot(slot, decoded_data)
                    self._update_data(oracle_id, new_data)  # ⭐ 每个oracle_id都存储
                except Exception as e:
                    # 某个解码器失败，继续尝试其他的
                    continue
```

**关键修正**：
- ✅ **遍历所有oracle_id**：类似Rust SDK的`for source in sources`
- ✅ **每个oracle_id都解码并存储**：类似Rust SDK的`update_handler(update, *source, &oraclemap)`

### 修正3：订阅确认处理 - 记录所有oracle_id

**修正后的订阅确认处理**：
```python
if isinstance(result, int):  # 订阅确认
    async with self._lock:
        subscription_id = result
        pubkey = None
        
        # 使用id字段匹配
        if hasattr(msg[0], 'id') and msg[0].id is not None:
            request_id = msg[0].id
            if request_id in self.inflight_subscribes:
                pubkey, _ = self.inflight_subscribes.pop(request_id)
        
        if pubkey:
            # 建立映射
            self.subscription_map[subscription_id] = pubkey
            self.pubkey_to_subscription[pubkey] = subscription_id
            
            # ⭐ 关键：为该pubkey的所有oracle_id建立映射
            if pubkey in self.pubkey_to_oracle_ids:
                for oracle_id in self.pubkey_to_oracle_ids[pubkey]:
                    self.oracle_id_to_subscription[oracle_id] = subscription_id
```

**关键修正**：
- ✅ **一个subscription_id对应多个oracle_id**：因为同一pubkey的所有oracle_id共享同一个订阅

---

## 总结：修正后的方案与Rust SDK的一致性

| 方面 | Rust SDK | 我的原始方案 | 修正后的方案 |
|------|----------|-------------|-------------|
| **订阅逻辑** | 同一pubkey只订阅一次 | ❌ 每个oracle_id都订阅 | ✅ 同一pubkey只订阅一次 |
| **存储key** | `(Pubkey, u8)` | ✅ `oracle_id` (字符串) | ✅ `oracle_id` (字符串) |
| **更新处理** | 遍历所有sources解码 | ⚠️ 尝试所有解码器选择 | ✅ 遍历所有oracle_id解码 |
| **共享检测** | 初始化时检测Mixed | ❌ 没有 | ⚠️ 通过pubkey_to_oracle_ids隐式检测 |

---

## 需要修正的关键点

1. **订阅逻辑**：同一pubkey只订阅一次，不是每个oracle_id都订阅
2. **更新处理**：收到更新时，遍历所有oracle_id解码并存储（类似Rust SDK的Mixed模式）
3. **订阅确认**：一个subscription_id对应多个oracle_id
