# 订阅、存储、读取链路完整检查

## 1. 订阅链路检查

### 1.1 订阅入口：`subscribe_to_oracle` / `subscribe_to_oracle_info`

**流程**：
```
subscribe_to_oracle(full_oracle_wrapper)
  → 检查 pubkey in pubkey_to_subscription
  → 如果已订阅：只添加 oracle_id 映射
  → 如果未订阅：调用 add_account(pubkey, decode_fn, oracle_id=oracle_id)
```

**检查点**：
- ✅ 使用 `pubkey` 检查避免重复订阅
- ✅ 传递 `oracle_id` 参数
- ✅ 建立 `oracle_id_to_pubkey` 映射

### 1.2 订阅核心：`add_account`

**流程**：
```
add_account(pubkey, decode_fn, oracle_id)
  → 检查 pubkey in pubkey_to_subscription（避免重复订阅）
  → 如果已订阅：只添加 oracle_id 映射
  → 如果未订阅：
    → 存储 decode_map[oracle_id] = decode_fn
    → 存储 data_map[oracle_id] = initial_data
    → 维护 pubkey_to_oracle_ids[pubkey].add(oracle_id)
    → 生成 request_id
    → 发送 JSON-RPC 订阅请求
```

**检查点**：
- ✅ 使用 `pubkey` 检查避免重复订阅
- ✅ 使用 `oracle_id` 作为 `decode_map` 和 `data_map` 的 key
- ✅ 维护 `pubkey_to_oracle_ids` 映射
- ✅ 使用 `request_id` 匹配（BUG2修复）

### 1.3 订阅确认：`_subscribe_ws` 中的确认处理

**流程**：
```
收到订阅确认（result是int）
  → 使用 msg[0].id 查找 inflight_subscribes
  → 获取 (pubkey, oracle_id)
  → 建立 subscription_map[subscription_id] = pubkey
  → 建立 pubkey_to_subscription[pubkey] = subscription_id
  → 为所有相关的 oracle_id 建立映射：
     oracle_id_to_subscription[oracle_id] = subscription_id
```

**检查点**：
- ✅ 使用 `request_id` 匹配（BUG2修复）
- ✅ 为所有 `oracle_id` 建立 `subscription_id` 映射

**潜在问题**：
- ⚠️ **问题1**：在订阅确认时，`pubkey_to_oracle_ids[pubkey]` 可能还没有包含所有 `oracle_id`
  - 场景：第一次订阅 `oracle_id1`，确认时只有 `{oracle_id1}`
  - 后续添加 `oracle_id2` 时，需要更新 `oracle_id_to_subscription[oracle_id2]`
  - **当前实现**：在 `subscribe_to_oracle_info` 中已处理（L234）

---

## 2. 存储链路检查

### 2.1 数据更新：`_subscribe_ws` 中的数据更新处理

**流程**：
```
收到数据更新（result.value存在）
  → 从 subscription_id 获取 pubkey
  → 获取 pubkey_to_oracle_ids[pubkey]（所有 oracle_id）
  → 遍历所有 oracle_id：
    → 获取 decode_map[oracle_id]
    → 解码 account_bytes
    → 调用 _update_data(oracle_id, new_data)
```

**检查点**：
- ✅ 遍历所有 `oracle_id`（BUG1修复）
- ✅ 使用 `oracle_id` 作为 key 存储数据

**潜在问题**：
- ⚠️ **问题2**：如果 `pubkey_to_oracle_ids[pubkey]` 为空，会进入 `else` 分支（非oracle账户）
  - 但如果是 oracle 账户，但 `pubkey_to_oracle_ids` 映射丢失，会导致数据无法存储
  - **当前实现**：有 `else` 分支处理非oracle账户，但需要确保 oracle 账户的映射不会丢失

### 2.2 数据存储：`_update_data`

**流程**：
```
_update_data(key: str, new_data)
  → 检查 current_data = data_map.get(key)
  → 如果 new_data.slot >= current_data.slot，更新 data_map[key] = new_data
```

**检查点**：
- ✅ 使用 `str` 类型的 key
- ✅ Slot 检查避免旧数据覆盖新数据

---

## 3. 读取链路检查

### 3.1 读取入口：`get_oracle_price_data_and_slot`

**流程**：
```
get_oracle_price_data_and_slot(oracle_id: str)
  → 直接调用 oracle_subscriber.get_data(oracle_id)
```

**检查点**：
- ✅ 直接使用 `oracle_id`（类似 Rust SDK 的 `MarketId`）

### 3.2 读取核心：`get_data`

**流程**：
```
get_data(key: Union[Pubkey, str])
  → 如果 key 是 Pubkey：
    → 获取 pubkey_to_oracle_ids[key]
    → 如果只有一个 oracle_id：使用它
    → 如果有多个 oracle_id：返回第一个（警告）
    → 如果没有 oracle_id：使用 str(pubkey)
  → 返回 data_map.get(key)
```

**检查点**：
- ✅ 支持 `Pubkey` 和 `str`（向后兼容）
- ✅ 处理多个 `oracle_id` 的情况

**潜在问题**：
- ⚠️ **问题3**：如果 `pubkey_to_oracle_ids[pubkey]` 为空，会使用 `str(pubkey)` 作为 key
  - 但对于 oracle 账户，应该使用 `oracle_id`，而不是 `str(pubkey)`
  - **当前实现**：对于非oracle账户，使用 `str(pubkey)` 是正确的

---

## 4. 潜在问题分析

### 问题1：订阅确认时 oracle_id 映射可能不完整

**场景**：
1. 第一次订阅 `oracle_id1`（pubkey）
2. 订阅确认时，`pubkey_to_oracle_ids[pubkey] = {oracle_id1}`
3. 确认处理：为 `{oracle_id1}` 建立 `oracle_id_to_subscription` 映射
4. 后续添加 `oracle_id2`（同一个pubkey）
5. 在 `subscribe_to_oracle_info` 中，会更新 `oracle_id_to_subscription[oracle_id2]`（L234）

**检查**：
- ✅ 已在 `subscribe_to_oracle_info` L234 处理
- ✅ 已在 `add_account` L68-69 处理

**结论**：✅ 已正确处理

---

### 问题2：数据更新时 pubkey_to_oracle_ids 为空

**场景**：
- Oracle 账户，但 `pubkey_to_oracle_ids[pubkey]` 为空（不应该发生）
- 会进入 `else` 分支，使用 `str(pubkey)` 作为 key
- 但 `decode_map[str(pubkey)]` 可能不存在（因为存储时使用的是 `oracle_id`）

**检查**：
- ⚠️ **潜在问题**：如果 `pubkey_to_oracle_ids` 映射丢失，数据更新会失败

**修复建议**：
- 在数据更新时，如果 `oracle_ids` 为空，但 `pubkey` 在 `pubkey_to_subscription` 中，应该尝试从 `decode_map` 中查找所有以 `pubkey` 开头的 key（oracle_id格式）

---

### 问题3：初始订阅时 oracle_id 映射

**场景**：
- 初始订阅时（`_subscribe_ws` L202-254），从 `data_map.keys()` 提取 `pubkey`
- 但此时 `pubkey_to_oracle_ids` 可能还没有建立（如果是在 `add_account` 之前调用 `subscribe()`）

**检查**：
- ⚠️ **潜在问题**：初始订阅时，`pubkey_to_oracle_ids` 可能不完整

**当前实现**：
- 在 `add_account` L83-87 中维护 `pubkey_to_oracle_ids`
- 在初始订阅时（L233），会从 `key` 中提取 `oracle_id`（如果 `key != str(pubkey)`）

**结论**：✅ 已正确处理

---

### 问题4：并发问题

**场景**：
- 多个协程同时调用 `add_account` 同一个 `pubkey`（不同的 `oracle_id`）
- 可能导致重复订阅

**检查**：
- ✅ 使用 `_lock` 保护关键区域
- ✅ 在 `add_account` L104-107 中再次检查（避免并发问题）

**结论**：✅ 已正确处理

---

## 5. 发现的潜在问题

### ⚠️ 问题A：数据更新时 pubkey_to_oracle_ids 为空的情况

**位置**：`multi_account_subscriber.py` L316-344

**问题**：
```python
oracle_ids = self.pubkey_to_oracle_ids.get(pubkey, set())

if oracle_ids:
    # 遍历所有 oracle_id
    ...
else:
    # 非 oracle 账户
    pubkey_str = str(pubkey)
    decode_fn = self.decode_map.get(pubkey_str)
    ...
```

**场景**：
- Oracle 账户，但 `pubkey_to_oracle_ids[pubkey]` 为空（不应该发生，但可能由于bug导致）
- 会进入 `else` 分支，尝试使用 `str(pubkey)` 作为 key
- 但 `decode_map[str(pubkey)]` 可能不存在（因为存储时使用的是 `oracle_id`）

**修复建议**：
- 在 `else` 分支中，如果 `pubkey` 在 `pubkey_to_subscription` 中，尝试查找所有以 `pubkey` 开头的 `oracle_id`（从 `decode_map.keys()` 中查找）

---

### ⚠️ 问题B：订阅确认时，新添加的 oracle_id 可能没有建立映射

**位置**：`multi_account_subscriber.py` L280-283

**问题**：
```python
# ⭐ 为所有相关的 oracle_id 建立映射
if pubkey in self.pubkey_to_oracle_ids:
    for oid in self.pubkey_to_oracle_ids[pubkey]:
        self.oracle_id_to_subscription[oid] = subscription_id
```

**场景**：
- 订阅确认时，`pubkey_to_oracle_ids[pubkey]` 可能只包含订阅时的 `oracle_id`
- 后续添加的 `oracle_id` 不会自动建立 `oracle_id_to_subscription` 映射
- **但**：在 `subscribe_to_oracle_info` L234 中已处理

**结论**：✅ 已正确处理（在 `subscribe_to_oracle_info` 中补充）

---

## 6. 总结

### ✅ 正确的部分

1. **订阅链路**：使用 `pubkey` 检查避免重复订阅，使用 `request_id` 匹配
2. **存储链路**：遍历所有 `oracle_id` 分别解码和存储
3. **读取链路**：支持 `Pubkey` 和 `str`，处理多个 `oracle_id` 的情况

### ⚠️ 潜在问题

1. **问题A**：数据更新时，如果 `pubkey_to_oracle_ids` 为空，会尝试使用 `str(pubkey)`，但 `decode_map[str(pubkey)]` 可能不存在
   - **影响**：数据更新失败，但不会崩溃
   - **修复优先级**：低（不应该发生，但可以添加容错处理）

2. **问题B**：订阅确认时，新添加的 `oracle_id` 映射
   - **状态**：✅ 已在 `subscribe_to_oracle_info` 中处理

### 建议

1. **添加容错处理**：在数据更新的 `else` 分支中，如果 `pubkey` 在 `pubkey_to_subscription` 中，尝试从 `decode_map.keys()` 中查找所有以 `pubkey` 开头的 key
2. **添加日志**：在关键位置添加日志，便于调试
