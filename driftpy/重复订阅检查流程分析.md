# 重复订阅检查流程分析

## 用户的担心

**场景**：同一个 `oracle`（pubkey）有多个不同的 `oracle_id`

例如：
- `PUMP-PERP` (PythLazer): `oracle_id1 = "pubkey-1"`
- `1KPUMP-PERP` (PythLazer1K): `oracle_id2 = "pubkey-2"`
- 两个 `oracle_id` 对应同一个 `pubkey`

**担心**：
```python
# _set_perp_oracle_map() 中
if oracle_id not in self.oracle_subscriber.data_map:
    await self.add_oracle(...)
```

如果：
1. 第一次：`oracle_id1 not in data_map` → `True` → 调用 `add_oracle()`
2. 第二次：`oracle_id2 not in data_map` → `True` → 又调用 `add_oracle()`

**会不会导致重复订阅？**

---

## 完整流程分析

### 第一次调用：`PUMP-PERP` (oracle_id1)

**步骤1：`_set_perp_oracle_map()`**
```python
oracle_id1 = "pubkey-1"  # PUMP-PERP
if oracle_id1 not in data_map:  # True（第一次，不存在）
    await self.add_oracle(OracleInfo(pubkey, PythLazer))
```

**步骤2：`add_oracle()` → `subscribe_to_oracle_info()`**
```python
# subscribe_to_oracle_info() 中
if oracle_info.pubkey in self.oracle_subscriber.pubkey_to_subscription:
    # False（第一次，未订阅）
    # 跳过这个分支

# pubkey 未订阅，需要订阅
await self.oracle_subscriber.add_account(
    pubkey,
    decode_fn,
    oracle_id=oracle_id1,  # ⭐ 传递 oracle_id1
)
```

**步骤3：`add_account()`**
```python
# add_account() 中
if pubkey in self.pubkey_to_subscription:
    # False（第一次，未订阅）
    # 跳过这个分支

# pubkey 未订阅，需要订阅
# 发送 JSON-RPC 订阅请求
# 订阅成功，建立映射：
# pubkey_to_subscription[pubkey] = subscription_id
# pubkey_to_oracle_ids[pubkey] = {oracle_id1}
# data_map[oracle_id1] = data1
```

**结果**：
- ✅ 订阅成功
- ✅ `pubkey_to_subscription[pubkey] = subscription_id`
- ✅ `data_map[oracle_id1] = data1`

---

### 第二次调用：`1KPUMP-PERP` (oracle_id2，同一个pubkey)

**步骤1：`_set_perp_oracle_map()`**
```python
oracle_id2 = "pubkey-2"  # 1KPUMP-PERP（同一个pubkey）
if oracle_id2 not in data_map:  # True（oracle_id2 确实不在 data_map 中）
    await self.add_oracle(OracleInfo(pubkey, PythLazer1K))
```

**步骤2：`add_oracle()` → `subscribe_to_oracle_info()`**
```python
# subscribe_to_oracle_info() 中
if oracle_info.pubkey in self.oracle_subscriber.pubkey_to_subscription:
    # ✅ True（pubkey 已经订阅了！）
    # pubkey 已经订阅，只需要添加 oracle_id 映射
    self.oracle_id_to_pubkey[oracle_id2] = pubkey
    self.oracle_subscriber.pubkey_to_oracle_ids[pubkey].add(oracle_id2)
    self.oracle_subscriber.oracle_id_to_subscription[oracle_id2] = subscription_id
    self.oracle_subscriber.decode_map[oracle_id2] = decode_fn
    return  # ⭐ 直接返回，不调用 add_account()！
```

**结果**：
- ✅ **不会重复订阅**（因为 `pubkey` 已经在 `pubkey_to_subscription` 中）
- ✅ 只添加 `oracle_id2` 的映射
- ✅ `data_map[oracle_id2] = data2`（通过后续的数据更新）

---

## 关键保护机制

### 保护层1：`subscribe_to_oracle_info()` 中的 `pubkey` 检查

```python
# subscribe_to_oracle_info() L224-237
if oracle_info.pubkey in self.oracle_subscriber.pubkey_to_subscription:
    # ✅ pubkey 已经订阅，只添加 oracle_id 映射
    return  # 不调用 add_account()
```

**作用**：即使 `oracle_id` 不同，如果 `pubkey` 已经订阅，就不会重复订阅。

### 保护层2：`add_account()` 中的 `pubkey` 检查

```python
# add_account() L61-74
if pubkey in self.pubkey_to_subscription:
    # ✅ pubkey 已经订阅，只添加 oracle_id 映射
    return  # 不发送订阅请求
```

**作用**：双重保护，确保不会重复订阅。

---

## 结论

### ✅ 不会重复订阅

**原因**：
1. `_set_perp_oracle_map()` 检查 `oracle_id not in data_map` 只是判断是否需要调用 `add_oracle()`
2. `add_oracle()` → `subscribe_to_oracle_info()` 会检查 `pubkey in pubkey_to_subscription`
3. 如果 `pubkey` 已经订阅，只添加 `oracle_id` 映射，**不会重复订阅**

### 流程总结

```
第一次：oracle_id1 (pubkey)
  → oracle_id1 not in data_map → True
  → add_oracle()
  → pubkey not in pubkey_to_subscription → True
  → add_account() → 订阅成功

第二次：oracle_id2 (同一个pubkey)
  → oracle_id2 not in data_map → True
  → add_oracle()
  → pubkey in pubkey_to_subscription → True ✅
  → 只添加 oracle_id2 映射，return（不订阅）
```

### 关键点

- `_set_perp_oracle_map()` 中的 `oracle_id not in data_map` 检查只是**判断是否需要调用 `add_oracle()`**
- 真正的订阅检查在 `subscribe_to_oracle_info()` 中：`pubkey in pubkey_to_subscription`
- 即使多个 `oracle_id` 对应同一个 `pubkey`，也只会订阅一次

---

## 优化建议（可选）

虽然不会重复订阅，但可以优化 `_set_perp_oracle_map()` 的检查逻辑：

**当前逻辑**：
```python
if oracle_id not in self.oracle_subscriber.data_map:
    await self.add_oracle(...)
```

**优化后**（更高效）：
```python
# 检查 pubkey 是否已订阅（更直接）
async with self.oracle_subscriber._lock:
    if oracle not in self.oracle_subscriber.pubkey_to_subscription:
        await self.add_oracle(...)
    else:
        # pubkey 已订阅，只需要确保 oracle_id 映射存在
        if oracle_id not in self.oracle_subscriber.data_map:
            # 手动添加 oracle_id 映射（不调用 add_oracle）
            oracle_id_to_pubkey[oracle_id] = oracle
            # ... 添加映射
```

**优点**：
- 避免不必要的 `add_oracle()` 调用
- 更直接地检查 `pubkey` 订阅状态

**但当前实现也是正确的**，因为 `subscribe_to_oracle_info()` 中有保护机制。
